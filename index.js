const TelegramBot = require('node-telegram-bot-api');
const schedule = require('node-schedule');
const moment = require('moment-timezone');

// Bot configuration
const TOKEN = '5847731188:AAF2vTmLyBHvdBYY4LSgJYQFqdbBL5IrSMY';
const CHANNEL_ID = -1002003497082;
const START_HOUR = 8;
const END_HOUR = 19;
const EARLY_MOTIVATION_HOUR = 5;
const ADMIN_USERNAME = '007';
const ADMIN_PASSWORD = '006007';
const AFFILIATE_URL = 'https://media1.placard.co.mz/redirect.aspx?pid=2197&bid=1690';
const TIMEZONE = 'Africa/Maputo';

// Console styling
const consoleStyle = {
  system: '\x1b[38;5;39m',  // Bright blue
  error: '\x1b[38;5;196m',  // Bright red
  success: '\x1b[38;5;82m', // Bright green
  warning: '\x1b[38;5;214m', // Bright orange
  info: '\x1b[38;5;147m',   // Light purple
  reset: '\x1b[0m'
};

// Enhanced ASCII Art
const ASCII_LOGO = `
${consoleStyle.system}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë             ü§ñ QUANTUM SIGNALS BOT v2.1              ‚ïë
‚ïë        [ SISTEMA QUANTUM INICIADO COM SUCESSO ]      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${consoleStyle.reset}`;

const ASCII_ERROR = `
${consoleStyle.error}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           ‚ö†Ô∏è  ALERTA DO SISTEMA QUANTUM             ‚ïë
‚ïë              [ FALHA DETECTADA ]                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${consoleStyle.reset}`;

const ASCII_MESSAGE = `
${consoleStyle.info}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           üì® NOVA MENSAGEM DETECTADA                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${consoleStyle.reset}`;

const ASCII_COMMAND = `
${consoleStyle.system}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           ‚å®Ô∏è  COMANDO ADMINISTRATIVO                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${consoleStyle.reset}`;

const ASCII_OPERATION = `
${consoleStyle.success}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           üéØ NOVA OPERA√á√ÉO INICIADA                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${consoleStyle.reset}`;

const ASCII_MAINTENANCE = `
${consoleStyle.warning}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           üîß MODO MANUTEN√á√ÉO ATIVADO                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${consoleStyle.reset}`;

// Console logging functions
const logSystem = (message) => console.log(`${consoleStyle.system}[SISTEMA] ‚û§ ${message}${consoleStyle.reset}`);
const logError = (message) => console.log(`${consoleStyle.error}[ERRO] ‚û§ ${message}${consoleStyle.reset}`);
const logSuccess = (message) => console.log(`${consoleStyle.success}[SUCESSO] ‚û§ ${message}${consoleStyle.reset}`);
const logWarning = (message) => console.log(`${consoleStyle.warning}[AVISO] ‚û§ ${message}${consoleStyle.reset}`);
const logInfo = (message) => console.log(`${consoleStyle.info}[INFO] ‚û§ ${message}${consoleStyle.reset}`);

class OperationsBot {
  constructor(token, channelId) {
    console.log(ASCII_LOGO);
    logSystem('Iniciando sistemas...');
    logSystem('Carregando m√≥dulos...');
    logSystem('Estabelecendo conex√£o com Telegram API...');
    
    this.bot = new TelegramBot(token, { polling: true });
    this.channelId = channelId;
    this.isOperating = false;
    this.maintenanceMode = false;
    this.stats = {
      totalOperations: 0,
      messagesSent: 0,
      dailyOperations: 0,
      maintenanceCount: 0,
      lastMaintenanceDate: null,
      systemUptime: Date.now()
    };
    this.adminSessions = new Map();
    this.startTime = Date.now();
    this.operationTimeout = null;
    this.forceOperating = false;
    this.customStartHour = START_HOUR;
    this.customEndHour = END_HOUR;
    this.pinnedMessageId = null;
    this.pinnedMessageTimer = null;
    this.customButtons = {
      button1: {
        text: 'üéØ Apostar Agora',
        url: AFFILIATE_URL
      },
      button2: {
        text: 'üìù Criar Conta',
        url: AFFILIATE_URL
      }
    };

    moment.tz.setDefault(TIMEZONE);
    
    logSuccess('Conex√£o estabelecida com sucesso!');
    logSystem('Configurando manipuladores de eventos...');

    this.setupErrorHandlers();
    this.setupCommands();
    this.setupSchedules();
    this.setupCallbackQueries();

    // Adicionar novo comando
    this.bot.onText(/\/tempo/, (msg) => this.handleTempoCommand(msg));

    // Iniciar opera√ß√µes automaticamente se estiver dentro do hor√°rio
    const currentHour = moment().hour();
    if (currentHour >= START_HOUR && currentHour < END_HOUR) {
      this.startOperations();
    }

    logSuccess('Sistema Quantum totalmente operacional!');
  }

  reconnect() {
    logWarning('Tentando reconectar ao servidor...');
    setTimeout(() => {
      try {
        this.bot.stopPolling();
        setTimeout(() => {
          this.bot.startPolling();
          logSuccess('Reconex√£o estabelecida com sucesso!');
        }, 1000);
      } catch (error) {
        logError(`Falha na reconex√£o: ${error}`);
        this.reconnect();
      }
    }, 5000);
  }

  setupErrorHandlers() {
    this.bot.on('error', (error) => {
      console.log(ASCII_ERROR);
      logError(`Erro detectado: ${error}`);
      this.reconnect();
    });

    this.bot.on('polling_error', (error) => {
      if (error.code !== 'EFATAL') {
        console.log(ASCII_ERROR);
        logWarning(`Erro de polling: ${error}`);
        this.reconnect();
      }
    });

    process.on('uncaughtException', (error) => {
      console.log(ASCII_ERROR);
      logError(`Erro n√£o tratado: ${error}`);
      this.reconnect();
    });
  }

  setupCommands() {
    this.bot.on('message', async (msg) => {
      try {
        console.log(ASCII_MESSAGE);
        logInfo(`Mensagem recebida de ${msg.from.id}: ${msg.text}`);
        await this.handleMessage(msg);
      } catch (error) {
        logError(`Erro ao processar mensagem: ${error}`);
      }
    });

    this.sendMessageWithRetry(this.channelId, 'ü§ñ Bot iniciado com sucesso!')
      .then(() => logSuccess('Mensagem de teste enviada com sucesso'))
      .catch(error => logError(`Erro ao enviar mensagem de teste: ${error}`));
  }

  async sendMessageWithRetry(chatId, message, options = {}, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        const result = await this.bot.sendMessage(chatId, message, options);
        logInfo(`Mensagem enviada para ${chatId}`);
        return result;
      } catch (error) {
        logError(`Tentativa ${i + 1} de envio falhou: ${error}`);
        if (i === maxRetries - 1) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
      }
    }
  }

  async handleTempoCommand(msg) {
    const chatId = msg.chat.id;
    const now = moment();
    
    // Calcular tempos restantes
    const nextOperation = moment().hour(START_HOUR).minute(0).second(0);
    if (now.isAfter(nextOperation)) {
      nextOperation.add(1, 'day');
    }

    const nextMotivation = moment().hour(EARLY_MOTIVATION_HOUR).minute(0).second(0);
    if (now.isAfter(nextMotivation)) {
      nextMotivation.add(1, 'day');
    }

    const operationsEnd = moment().hour(END_HOUR).minute(0).second(0);
    if (now.isAfter(operationsEnd)) {
      operationsEnd.add(1, 'day');
    }

    const nightBlessing = moment().hour(20).minute(0).second(0);
    if (now.isAfter(nightBlessing)) {
      nightBlessing.add(1, 'day');
    }

    const message = 
      "‚è∞ *TEMPOS RESTANTES*\n\n" +
      `üåÖ Motiva√ß√£o: ${moment.duration(nextMotivation.diff(now)).format("HH:mm:ss")}\n` +
      `üéØ Opera√ß√µes: ${moment.duration(nextOperation.diff(now)).format("HH:mm:ss")}\n` +
      `üîö Fim Opera√ß√µes: ${moment.duration(operationsEnd.diff(now)).format("HH:mm:ss")}\n` +
      `üåô B√™n√ß√£o Noturna: ${moment.duration(nightBlessing.diff(now)).format("HH:mm:ss")}`;

    await this.sendMessageWithRetry(chatId, message, { parse_mode: 'Markdown' });
  }

  async handleMessage(msg) {
    if (!msg.chat || msg.chat.type !== 'private') return;
    
    const chatId = msg.chat.id;
    const text = msg.text || '';
    const session = this.adminSessions.get(chatId) || { step: 'start' };

    try {
      if (text.startsWith('/')) {
        console.log(ASCII_COMMAND);
        logInfo(`Comando recebido: ${text}`);
        await this.handleAdminCommand(chatId, text);
        return;
      }

      switch (session.step) {
        case 'start':
          await this.sendMessageWithRetry(chatId, 'Ol√°, bem-vindo ao painel admin!\nDigite seu username:');
          session.step = 'username';
          break;

        case 'username':
          if (text === ADMIN_USERNAME) {
            await this.sendMessageWithRetry(chatId, 'Digite sua senha:');
            session.step = 'password';
            logInfo(`Tentativa de login: username correto de ${chatId}`);
          } else {
            await this.sendMessageWithRetry(chatId, 'Username incorreto. Tente novamente.\nDigite seu username:');
            logWarning(`Tentativa de login: username incorreto de ${chatId}`);
          }
          break;

        case 'password':
          if (text === ADMIN_PASSWORD) {
            session.step = 'authenticated';
            await this.sendAdminMenu(chatId);
            logSuccess(`Login bem-sucedido: ${chatId}`);
          } else {
            await this.sendMessageWithRetry(chatId, 'Senha incorreta. Acesso negado.');
            logWarning(`Tentativa de login: senha incorreta de ${chatId}`);
            session.step = 'start';
          }
          break;

        case 'waiting_announcement':
          if (msg.photo || msg.video || msg.document) {
            session.mediaType = msg.photo ? 'photo' : msg.video ? 'video' : 'document';
            session.mediaId = msg.photo ? msg.photo[msg.photo.length - 1].file_id : 
                           msg.video ? msg.video.file_id : 
                           msg.document.file_id;
            await this.sendMessageWithRetry(chatId, 'Agora digite o texto do comunicado:', { reply_markup: { force_reply: true } });
            session.step = 'waiting_announcement_text';
          } else {
            session.announcementText = msg.text;
            await this.sendMessageWithRetry(chatId, 'Digite o texto para o primeiro bot√£o:', { reply_markup: { force_reply: true } });
            session.step = 'waiting_button1_text';
          }
          break;

        case 'waiting_announcement_text':
          session.announcementText = msg.text;
          await this.sendMessageWithRetry(chatId, 'Digite o texto para o primeiro bot√£o:', { reply_markup: { force_reply: true } });
          session.step = 'waiting_button1_text';
          break;

        case 'waiting_button1_text':
          session.button1Text = text;
          await this.sendMessageWithRetry(
            chatId,
            'Digite o link para o primeiro bot√£o:',
            { reply_markup: { force_reply: true } }
          );
          session.step = 'waiting_button1_url';
          break;

        case 'waiting_button1_url':
          session.button1Url = text;
          await this.sendMessageWithRetry(
            chatId,
            'Digite o texto para o segundo bot√£o:',
            { reply_markup: { force_reply: true } }
          );
          session.step = 'waiting_button2_text';
          break;

        case 'waiting_button2_text':
          session.button2Text = text;
          await this.sendMessageWithRetry(
            chatId,
            'Digite o link para o segundo bot√£o:',
            { reply_markup: { force_reply: true } }
          );
          session.step = 'waiting_button2_url';
          break;

        case 'waiting_button2_url':
          session.button2Url = text;
          await this.sendAnnouncement(chatId, session);
          session.step = 'authenticated';
          break;

        case 'waiting_pin_message':
          await this.sendPinnedMessage(chatId, text);
          session.step = 'authenticated';
          break;

        default:
          session.step = 'authenticated';
          await this.sendAdminMenu(chatId);
          break;
      }

      this.adminSessions.set(chatId, session);
    } catch (error) {
      logError(`Erro ao processar mensagem: ${error}`);
      await this.sendMessageWithRetry(chatId, '‚ùå Erro ao processar mensagem. Tente novamente.');
    }
  }

  async handleAdminCommand(chatId, command) {
    const session = this.adminSessions.get(chatId);
    if (!session || session.step !== 'authenticated') {
      await this.sendMessageWithRetry(chatId, '‚ö†Ô∏è Voc√™ precisa fazer login primeiro!');
      return;
    }

    switch (command) {
      case '/stats':
        await this.sendStats(chatId);
        break;
      case '/menu':
        await this.sendAdminMenu(chatId);
        break;
      case '/help':
        await this.sendHelp(chatId);
        break;
      case '/report':
        await this.sendDailyReport(chatId);
        break;
      case '/morning':
        await this.sendMorningMotivation();
        break;
      case '/night':
        await this.sendNightBlessing();
        break;
      default:
        await this.sendMessageWithRetry(chatId, '‚ùå Comando n√£o reconhecido. Use /help para ver os comandos dispon√≠veis.');
    }
  }

  async sendAdminMenu(chatId) {
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üîß Ativar Manuten√ß√£o', callback_data: 'maintenance_on' },
          { text: '‚úÖ Desativar Manuten√ß√£o', callback_data: 'maintenance_off' }
        ],
        [
          { text: '‚ö°Ô∏è For√ßar In√≠cio', callback_data: 'force_start' },
          { text: 'üîí Parar For√ßa', callback_data: 'force_stop' }
        ],
        [
          { text: 'üì¢ Enviar Comunicado', callback_data: 'send_announcement' },
          { text: '‚öôÔ∏è Configurar Bot√µes', callback_data: 'config_buttons' }
        ],
        [
          { text: 'üìå Fixar Mensagem', callback_data: 'pin_message' },
          { text: 'üìä Ver Estat√≠sticas', callback_data: 'view_stats' }
        ],
        [
          { text: 'üåÖ Motiva√ß√£o Madrugada', callback_data: 'send_early_motivation' },
          { text: 'üåô B√™n√ß√£o Noturna', callback_data: 'send_night_blessing' }
        ],
        [
          { text: 'üíª Info Sistema', callback_data: 'system_info' },
          { text: 'üîß Stats Manuten√ß√£o', callback_data: 'maintenance_stats' }
        ]
      ]
    };

    const status = 
      `ü§ñ *Painel de Controle v2.1*\n\n` +
      `üìä *Status Atual:*\n` +
      `${this.maintenanceMode ? 'üîß Em Manuten√ß√£o' : '‚úÖ Operacional'}\n` +
      `${this.isOperating ? '‚ñ∂Ô∏è Operando' : '‚èπÔ∏è Pausado'}\n` +
      `${this.forceOperating ? '‚ö°Ô∏è Modo For√ßa Ativo' : 'üîí Modo Normal'}\n\n` +
      `‚è∞ Hor√°rio: ${this.customStartHour}:00 - ${this.customEndHour}:00`;

    await this.sendMessageWithRetry(chatId, status, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async sendSystemInfo(chatId) {
    const uptime = moment.duration(Date.now() - this.stats.systemUptime).humanize();
    const info = 
      `üíª *Informa√ß√µes do Sistema*\n\n` +
      `üïí Uptime: ${uptime}\n` +
      `üåê Timezone: ${TIMEZONE}\n` +
      `üì° Vers√£o: 2.1\n` +
      `üîÑ √öltima Reinicializa√ß√£o: ${moment(this.stats.systemUptime).format('DD/MM/YYYY HH:mm:ss')}\n\n` +
      `‚öôÔ∏è *Configura√ß√µes:*\n` +
      `‚ñ´Ô∏è In√≠cio: ${this.customStartHour}:00\n` +
      `‚ñ´Ô∏è T√©rmino: ${this.customEndHour}:00\n` +
      `‚ñ´Ô∏è Motivacional: 05:00\n` +
      `‚ñ´Ô∏è B√™n√ß√£o: 20:00`;

    await this.sendMessageWithRetry(chatId, info, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[{ text: 'üîô Voltar', callback_data: 'back_to_menu' }]]
      }
    });
  }

  async sendMaintenanceStats(chatId) {
    const stats = 
      `üîß *Estat√≠sticas de Manuten√ß√£o*\n\n` +
      `üìä Total de Manuten√ß√µes: ${this.stats.maintenanceCount}\n` +
      `üïí √öltima Manuten√ß√£o: ${this.stats.lastMaintenanceDate || 'Nenhuma'}\n\n` +
      `üìà *Status Atual:*\n` +
      `${this.maintenanceMode ? 'üîß Em Manuten√ß√£o' : '‚úÖ Sistema Operacional'}`;

    await this.sendMessageWithRetry(chatId, stats, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[{ text: 'üîô Voltar', callback_data: 'back_to_menu' }]]
      }
    });
  }

  async sendOperation() {
    if (!this.isOperating || this.maintenanceMode) return;

    try {
      console.log(ASCII_OPERATION);
      const multiplier = (Math.random() * (6.99 - 1.00) + 1.00).toFixed(2);
      const keyboard = {
        inline_keyboard: [
          [{ text: this.customButtons.button1.text, url: this.customButtons.button1.url }],
          [{ text: this.customButtons.button2.text, url: this.customButtons.button2.url }]
        ]
      };

      const nextOperationTime = moment().add(3, 'minutes').format('HH:mm');

      logInfo(`Enviando opera√ß√£o com multiplicador ${multiplier}x`);
      await this.sendMessageWithRetry(
        this.channelId,
        `üéØ *NOVA OPORTUNIDADE!*\n\n` +
        `‚ö°Ô∏è Multiplicador: ${multiplier}x\n` +
        `‚è∞ Entrada: ${nextOperationTime}\n\n` +
        `‚ö†Ô∏è Saia antes do crash!\n` +
        `‚úÖ Fa√ßa sua entrada agora!`,
        {
          parse_mode: 'Markdown',
          reply_markup: keyboard
        }
      );
      
      this.stats.messagesSent++;
      this.stats.totalOperations++;
      this.stats.dailyOperations++;
      logSuccess(`Opera√ß√£o #${this.stats.totalOperations} enviada com sucesso`);

      setTimeout(() => this.sendResult(), 3 * 60 * 1000);
    } catch (error) {
      logError(`Erro ao enviar opera√ß√£o: ${error}`);
      this.scheduleNextOperation();
    }
  }

  async sendResult() {
    try {
      await this.sendMessageWithRetry(
        this.channelId,
        `üîÑ *OPERA√á√ÉO ENCERRADA*\n\n` +
        `üìä Pr√≥xima opera√ß√£o em breve!`,
        { parse_mode: 'Markdown' }
      );

      this.scheduleNextOperation();
    } catch (error) {
      logError(`Erro ao enviar resultado: ${error}`);
      this.scheduleNextOperation();
    }
  }

  scheduleNextOperation() {
    if (!this.isOperating || this.maintenanceMode) return;

    const now = moment();
    const hour = now.hour();

    if ((hour >= this.customStartHour && hour < this.customEndHour) || this.forceOperating) {
      const delay = Math.floor(Math.random() * (180000 - 60000) + 60000); // 1-3 minutes
      this.operationTimeout = setTimeout(() => this.sendOperation(), delay);
      logInfo(`Pr√≥xima opera√ß√£o agendada para ${moment().add(delay, 'milliseconds').format('HH:mm:ss')}`);
    } else {
      this.isOperating = false;
      logInfo('Fora do hor√°rio de opera√ß√µes');
    }
  }

  setupSchedules() {
    logSystem('Configurando agendamentos...');
    
    // Reset daily stats at midnight
    schedule.scheduleJob('0 0 * * *', () => {
      this.stats.dailyOperations = 0;
      logInfo('Contador de opera√ß√µes di√°rias resetado');
    });

    // Early morning motivation at 5 AM sharp
    schedule.scheduleJob('0 5 * * *', () => {
      logInfo('Enviando mensagem motivacional da madrugada');
      this.sendEarlyMotivation();
    });

    // Pre-operation notification at 7 AM
    schedule.scheduleJob('0 7 * * *', () => {
      logInfo('Enviando aviso de in√≠cio de opera√ß√µes');
      this.sendPreOperationNotice();
    });

    // Start operations exactly at 8 AM
    schedule.scheduleJob('0 8 * * *', () => {
      if (!this.maintenanceMode) {
        logInfo('Iniciando opera√ß√µes programadas');
        this.startOperations();
      }
    });

    // End operations exactly at 7 PM
    schedule.scheduleJob('0 19 * * *', () => {
      logInfo('Encerrando opera√ß√µes programadas');
      this.endOperations();
      this.sendEndOperationNotice();
    });

    // Night blessing at 8 PM
    schedule.scheduleJob('0 20 * * *', () => {
      logInfo('Enviando b√™n√ß√£o noturna');
      this.sendNightBlessing();
    });

    // System health check every hour
    schedule.scheduleJob('0 * * * *', () => {
      this.performHealthCheck();
    });

    logSuccess('Agendamentos configurados com sucesso');
  }

  async sendPreOperationNotice() {
    const message = 
      "üö® *ATEN√á√ÉO - OPERA√á√ïES INICIAM EM 1 HORA*\n\n" +
      "üìà Prepare-se para mais um dia de opera√ß√µes!\n\n" +
      "‚ö†Ô∏è *AVISOS IMPORTANTES:*\n" +
      "‚Ä¢ Fa√ßa seu dep√≥sito agora para operar desde o in√≠cio\n" +
      "‚Ä¢ Novatos: Criem suas contas pelo bot√£o abaixo\n" +
      "‚Ä¢ Opere na mesma casa que o mentor\n" +
      "‚Ä¢ Mesmo gr√°fico = Maiores chances de sucesso\n\n" +
      "üéØ *HOR√ÅRIO DAS OPERA√á√ïES:*\n" +
      "‚Ä¢ Segunda a Sexta: 8h √†s 19h\n\n" +
      "üë®‚Äçüè´ *MENTORIA AO VIVO:*\n" +
      "‚Ä¢ Toda Sexta-feira\n" +
      "‚Ä¢ Das 20h √†s 21h\n\n" +
      "‚úÖ Clique no bot√£o abaixo para criar sua conta:";

    const keyboard = {
      inline_keyboard: [
        [{ text: 'üìù CRIAR CONTA AGORA', url: AFFILIATE_URL }],
        [{ text: 'üí∞ FAZER DEP√ìSITO', url: AFFILIATE_URL }]
      ]
    };

    await this.sendMessageWithRetry(this.channelId, message, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async sendEndOperationNotice() {
    const message = 
      "üîî *ENCERRAMENTO DAS OPERA√á√ïES*\n\n" +
      "‚úÖ Opera√ß√µes encerradas por hoje!\n\n" +
      "üìÖ *PR√ìXIMAS ATIVIDADES:*\n" +
      "‚Ä¢ Opera√ß√µes: Amanh√£ das 8h √†s 19h\n" +
      `${moment().day() === 5 ? "‚Ä¢ Mentoria HOJE √†s 20h!\n" : "‚Ä¢ Mentoria: Sexta-feira √†s 20h\n"}\n` +
      "‚ö°Ô∏è *PREPARA√á√ÉO PARA AMANH√É:*\n" +
      "‚Ä¢ Fa√ßa seu dep√≥sito\n" +
      "‚Ä¢ Verifique seu saldo\n" +
      "‚Ä¢ Prepare suas estrat√©gias\n\n" +
      "üéØ Crie sua conta na casa indicada abaixo:";

    const keyboard = {
      inline_keyboard: [
        [{ text: 'üìù CRIAR CONTA AGORA', url: AFFILIATE_URL }],
        [{ text: 'üí∞ FAZER DEP√ìSITO', url: AFFILIATE_URL }]
      ]
    };

    await this.sendMessageWithRetry(this.channelId, message, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async performHealthCheck() {
    const uptime = moment.duration(Date.now() - this.stats.systemUptime).humanize();
    const currentHour = moment().hour();
    const shouldBeOperating = currentHour >= START_HOUR && currentHour < END_HOUR;

    if (shouldBeOperating && !this.isOperating && !this.maintenanceMode) {
      logWarning('Sistema detectou inconsist√™ncia no estado de opera√ß√£o');
      this.startOperations();
    }

    if (!shouldBeOperating && this.isOperating && !this.forceOperating) {
      logWarning('Sistema detectou opera√ß√µes fora do hor√°rio');
      this.endOperations();
    }

    logInfo(`Verifica√ß√£o de sa√∫de do sistema - Uptime: ${uptime}`);
  }

  async sendEarlyMotivation() {
    const messages = [
      "üåÖ *MOTIVA√á√ÉO DA MADRUGADA*\n\n" +
      "\"Acordai, v√≥s que dormis, e levantai-vos dentre os mortos, e Cristo vos esclarecer√°.\" - Ef√©sios 5:14\n\n" +
      "üí´ Um novo dia de oportunidades se inicia!\n" +
      "üôè Que Deus aben√ßoe nossos objetivos\n" +
      "‚ú® Prepare-se para mais um dia vitorioso!",

      "üåÑ *DESPERTAR VITORIOSO*\n\n" +
      "\"O Senhor √© a minha for√ßa e o meu escudo.\" - Salmos 28:7\n\n" +
      "üåü A madrugada traz novas possibilidades\n" +
      "üí™ Sua dedica√ß√£o ser√° recompensada\n" +
      "‚ú® Vamos juntos em busca das conquistas!",

      "üåÖ *BEN√á√ÉO MATINAL*\n\n" +
      "\"As miseric√≥rdias do Senhor se renovam a cada manh√£.\" - Lamenta√ß√µes 3:23\n\n" +
      "üôè Que este dia seja repleto de vit√≥rias\n" +
      "üí´ Sua persist√™ncia √© sua maior for√ßa\n" +
      "‚ú® Deus est√° no controle de tudo!",

      "üåÖ *AMAN HECER ABEN√áOADO*\n\n" +
      "\"Tudo posso naquele que me fortalece.\" - Filipenses 4:13\n\n" +
      "üôè Deus est√° contigo nesta madrugada\n" +
      "üí´ Seu potencial √© ilimitado\n" +
      "‚ú® Hoje ser√° um dia de vit√≥rias!",

      "üåÑ *DESPERTAR COM DEUS*\n\n" +
      "\"Entrega o teu caminho ao Senhor; confia nele, e ele tudo far√°.\" - Salmos 37:5\n\n" +
      "üåü Sua dedica√ß√£o ser√° recompensada\n" +
      "üí™ Mantenha sua f√© inabal√°vel\n" +
      "‚ú® Grandes conquistas te aguardam!",

      "üåÖ *MANH√É DE VIT√ìRIAS*\n\n" +
      "\"Porque sou eu que conhe√ßo os planos que tenho para voc√™s, diz o Senhor.\" - Jeremias 29:11\n\n" +
      "üôè Deus tem um prop√≥sito especial para voc√™\n" +
      "üí´ Sua persist√™ncia √© admir√°vel\n" +
      "‚ú® Continue firme em seus objetivos!",

      "üåÑ *AURORA DE B√äN√á√ÉOS*\n\n" +
      "\"O Senhor √© minha luz e minha salva√ß√£o; de quem terei temor?\" - Salmos 27:1\n\n" +
      "üåü Comece o dia com determina√ß√£o\n" +
      "üí™ Sua for√ßa vem do Senhor\n" +
      "‚ú® Vit√≥rias te aguardam!",

      "üåÖ *DESPERTAR COM F√â*\n\n" +
      "\"Sejam fortes e corajosos. N√£o tenham medo nem fiquem apavorados.\" - Deuteron√¥mio 31:6\n\n" +
      "üôè Deus est√° no controle\n" +
      "üí´ Sua dedica√ß√£o ser√° recompensada\n" +
      "‚ú® Hoje √© dia de conquistas!",

      "üåÑ *AMANHECER DE PROP√ìSITOS*\n\n" +
      "\"Antes que te formasse no ventre te conheci.\" - Jeremias 1:5\n\n" +
      "üåü Voc√™ tem um prop√≥sito especial\n" +
      "üí™ Deus planejou cada detalhe\n" +
      "‚ú® Siga em frente com f√©!",

      "üåÖ *MANH√É DE ESPERAN√áA*\n\n" +
      "üôè Confie no tempo de Deus\n" +
      "üí´ Seus sonhos s√£o poss√≠veis\n" +
      "‚ú® Mantenha sua f√© viva!"
    ];

    const randomIndex = Math.floor(Math.random() * messages.length);
    const message = messages[randomIndex];

    await this.sendMessageWithRetry(this.channelId, message, {
      parse_mode: 'Markdown'
    });
  }

  async sendNightBlessing() {
    const message = 
      "üåô *B√äN√á√ÉO NOTURNA*\n\n" +
      "\"O Senhor te aben√ßoe e te guarde; o Senhor fa√ßa resplandecer o seu rosto sobre ti e te conceda gra√ßa; o Senhor volte para ti o seu rosto e te d√™ paz.\" - N√∫meros 6:24-26\n\n" +
      "‚ú® Que sua noite seja aben√ßoada\n" +
      "üôè Descanse em paz\n" +
      "üí´ Amanh√£ ser√° um novo dia de vit√≥rias!";

    await this.sendMessageWithRetry(this.channelId, message, {
      parse_mode: 'Markdown'
    });
  }

  startOperations() {
    if (this.maintenanceMode) {
      logWarning('Tentativa de iniciar opera√ß√µes durante manuten√ß√£o');
      return;
    }

    this.isOperating = true;
    this.scheduleNextOperation();
    logSuccess('Opera√ß√µes iniciadas');
  }

  endOperations() {
    this.isOperating = false;
    if (this.operationTimeout) {
      clearTimeout(this.operationTimeout);
      this.operationTimeout = null;
    }
    logInfo('Opera√ß√µes encerradas');
  }

  setupCallbackQueries() {
    this.bot.on('callback_query', async (query) => {
      const chatId = query.message.chat.id;
      const session = this.adminSessions.get(chatId);

      if (!session || session.step !== 'authenticated') {
        await this.bot.answerCallbackQuery(query.id, {
          text: '‚ö†Ô∏è Voc√™ precisa fazer login primeiro!',
          show_alert: true
        });
        return;
      }

      try {
        switch (query.data) {
          case 'maintenance_on':
            this.maintenanceMode = true;
            this.stats.maintenanceCount++;
            this.stats.lastMaintenanceDate = moment().format('DD/MM/YYYY HH:mm:ss');
            await this.sendMessageWithRetry(this.channelId, 'üîß *SISTEMA EM MANUTEN√á√ÉO*\n\nOpera√ß√µes temporariamente suspensas.', { parse_mode: 'Markdown' });
            break;

          case 'maintenance_off':
            this.maintenanceMode = false;
            await this.sendMessageWithRetry(this.channelId, '‚úÖ *SISTEMA OPERACIONAL*\n\nOpera√ß√µes normalizadas.', { parse_mode: 'Markdown' });
            break;

          case 'force_start':
            this.forceOperating = true;
            this.startOperations();
            break;

          case 'force_stop':
            this.forceOperating = false;
            if (!this.isInOperatingHours()) {
              this.endOperations();
            }
            break;

          case 'send_announcement':
            session.step = 'waiting_announcement';
            await this.sendMessageWithRetry(chatId, 'Digite o texto do comunicado ou envie uma m√≠dia (foto/v√≠deo/documento):', { reply_markup: { force_reply: true } });
            break;

          case 'config_buttons':
            session.step = 'waiting_button1_text';
            await this.sendMessageWithRetry(chatId, 'Digite o texto para o primeiro bot√£o:', { reply_markup: { force_reply: true } });
            break;

          case 'pin_message':
            session.step = 'waiting_pin_message';
            await this.sendMessageWithRetry(chatId, 'Digite a mensagem que deseja fixar:', { reply_markup: { force_reply: true } });
            break;

          case 'view_stats':
            await this.sendStats(chatId);
            break;

          case 'send_early_motivation':
            await this.sendEarlyMotivation();
            break;

          case 'send_night_blessing':
            await this.sendNightBlessing();
            break;

          case 'system_info':
            await this.sendSystemInfo(chatId);
            break;

          case 'maintenance_stats':
            await this.sendMaintenanceStats(chatId);
            break;

          case 'back_to_menu':
            await this.sendAdminMenu(chatId);
            break;
        }

        await this.bot.answerCallbackQuery(query.id);
        this.adminSessions.set(chatId, session);
      } catch (error) {
        logError(`Erro ao processar callback query: ${error}`);
        await this.bot.answerCallbackQuery(query.id, {
          text: '‚ùå Erro ao processar comando',
          show_alert: true
        });
      }
    });
  }

  isInOperatingHours() {
    const currentHour = moment().hour();
    return currentHour >= this.customStartHour && currentHour < this.customEndHour;
  }

  async sendAnnouncement(chatId, session) {
    try {
      const keyboard = {
        inline_keyboard: [
          [{ text: session.button1Text, url: session.button1Url }],
          [{ text: session.button2Text, url: session.button2Url }]
        ]
      };

      if (session.mediaId) {
        switch (session.mediaType) {
          case 'photo':
            await this.bot.sendPhoto(this.channelId, session.mediaId, {
              caption: session.announcementText,
              parse_mode: 'Markdown',
              reply_markup: keyboard
            });
            break;
          case 'video':
            await this.bot.sendVideo(this.channelId, session.mediaId, {
              caption: session.announcementText,
              parse_mode: 'Markdown',
              reply_markup: keyboard
            });
            break;
          case 'document':
            await this.bot.sendDocument(this.channelId, session.mediaId, {
              caption: session.announcementText,
              parse_mode: 'Markdown',
              reply_markup: keyboard
            });
            break;
        }
      } else {
        await this.sendMessageWithRetry(this.channelId, session.announcementText, {
          parse_mode: 'Markdown',
          reply_markup: keyboard
        });
      }

      await this.sendMessageWithRetry(chatId, '‚úÖ Comunicado enviado com sucesso!');
      await this.sendAdminMenu(chatId);
    } catch (error) {
      logError(`Erro ao enviar comunicado: ${error}`);
      await this.sendMessageWithRetry(chatId, '‚ùå Erro ao enviar comunicado. Tente novamente.');
      await this.sendAdminMenu(chatId);
    }
  }

  async sendStats(chatId) {
    const uptime = moment.duration(Date.now() - this.startTime).humanize();
    const stats = 
      `üìä *Estat√≠sticas do Sistema*\n\n` +
      `üî¢ Total de Opera√ß√µes: ${this.stats.totalOperations}\n` +
      `üìà Opera√ß√µes Hoje: ${this.stats.dailyOperations}\n` +
      `üì® Mensagens Enviadas: ${this.stats.messagesSent}\n` +
      `‚è±Ô∏è Uptime: ${uptime}\n\n` +
      `üïí √öltima Atualiza√ß√£o: ${moment().format('DD/MM/YYYY HH:mm:ss')}`;

    await this.sendMessageWithRetry(chatId, stats, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[{ text: 'üîô Voltar', callback_data: 'back_to_menu' }]]
      }
    });
  }

  async sendHelp(chatId) {
    const help = 
      `‚ÑπÔ∏è *Comandos Dispon√≠veis*\n\n` +
      `üîπ /menu - Mostra o menu principal\n` +
      `üîπ /stats - Mostra estat√≠sticas do sistema\n` +
      `üîπ /report - Gera relat√≥rio di√°rio\n` +
      `üîπ /morning - Envia mensagem motivacional\n` +
      `üîπ /night - Envia b√™n√ß√£o noturna\n` +
      `üîπ /tempo - Mostra tempos restantes\n` +
      `üîπ /help - Mostra esta mensagem`;

    await this.sendMessageWithRetry(chatId, help, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[{ text: 'üîô Voltar', callback_data: 'back_to_menu' }]]
      }
    });
  }

  async sendDailyReport(chatId) {
    const report = 
      `üìã *Relat√≥rio Di√°rio*\n\n` +
      `üìä Opera√ß√µes Realizadas: ${this.stats.dailyOperations}\n` +
      `üìà Taxa de Sucesso: ${((this.stats.dailyOperations / this.stats.totalOperations) * 100).toFixed(2)}%\n` +
      `‚è±Ô∏è Tempo em Opera√ß√£o: ${moment.duration(Date.now() - this.startTime).humanize()}\n\n` +
      `üìÖ Data: ${moment().format('DD/MM/YYYY')}\n` +
      `üïí Hora: ${moment().format('HH:mm:ss')}`;

    await this.sendMessageWithRetry(chatId, report, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[{ text: 'üîô Voltar', callback_data: 'back_to_menu' }]]
      }
    });
  }
}

// Initialize the bot
const bot = new OperationsBot(TOKEN, CHANNEL_ID);
